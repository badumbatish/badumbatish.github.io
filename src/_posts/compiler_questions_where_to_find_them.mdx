---
title: 'Compiler (related) questions and where to find them'
date: 2025-4-17
recap: "Jasmine helps new grads in compiler by sharing interview questions through her new grad recruiting journey"
---

# Prologue

Hi everyone, how's everyone doing? It's been a while since I've written another blog. I'm doing good :) This May
2025,
I'm graduating and happy to announce that I'm starting my employment at Igalia this June hacking on compilers :)

Igalia is a
"worker-owned, employee-run cooperative model consultancy focused on open source software" and I'm so happy I am
accepted and offered to work here. I'll be working remotely from home, hacking on compilers :) Besides the
diversity and the worker cooperative model, family and work-life
balance also play a huge role in my life, hence my pick for Igalia.

During my compiler-focused recruiting time, in interviews, I got asked a lot of compiler-related questions and I felt
really
under-prepared for them. I of course have some experience in compilers, but there wasn't a database like leetcode
that you
can turn to to practice and hone your compiler skills. I want to write this article to talk about compiler (related)
questions
asked in interviews,
to share with everyone who's
looking for a junior job; maybe it can help you with your compiler recruiting.

I want to also extend my acknowledgement to everyone who believed in me and supported me throughout, including, but
not excluding:

- My family: you already know what it is haha
- Emi & Noah: for being there for me and helping me with offer decisions :)
- Lizzie: your mom hhahahah
- Tim: For your help in the Igalia process.
- Ish: for your "youll b fine" and "itll b fine" affirmations :)
- Quân: for Yosemite and for everything since 2023.
- Carol: For your acceptance and support to me during Fermilab's CCI and SULI program. You helped shape my early-early-early career.
- Eduardo: For befriending me and for shuriken-analyzer :)
- Antonio: For referring me to mmm and nnn :)
- Arthur: for your support during GSoc and GT.
- Josh: For referring me to different companies, helping me with offer negotiation and going on walks with me :)
- Nicole, Roger and everyone for your patience.
- Brian and James: For our little biweekly virtual meet up since Fall 2023 :)
- Max & Audrey: for your CS265 class and for SIGPLAN-M :)
- Jasmangle: for chatting with me through the hiring cycles and helping me with my leetcode.
- Ahmad: for chatting and being dumb with me through the latter half of the recruitment cycle.
- Barbara: for practicing Leetcode with me (fall 2024).
- Sriram: For your reference.
- Iman: For referring me to xxx and yyy :) I'll always be grateful to you.

As is tradition :) I also want to recommend two songs for this article. One is
[Iris by Ashes to Amber](https://youtu.be/UfvULU7lx4w?si=NMlUofaIGxrRST8N) and the other
one is [Strawberry Sunscreen by Lostboycrow](https://youtu.be/eUCHyIfgnag?si=_WTWbSJzplEHmEWY).

Both give my heart this feeling that summer is coming through soon; that the heat of youth will strive again and
that I'll be on the beach again :) I guess now you know which season is my favorite :)

The article is around 5000 words, with the reading time around 20 minutes. I hope everyone enjoys :)
# Introduction

> It's often discouraging as a new grad to feel like no matter how much effort you put in, it's never quite enough.

In
this currently dire and over-competitive economy, once you
apply for a role,
it's
hard to compete and get past the OA stage; once you get past the OA stage, it's
hard to compete and get
past the resume
screen
stage; once you get
past the resume screen stage, it's hard to compete and get past the interview stage.

Companies are asking (compiler) questions that are often not
addressed in your average compiler class, and it's hard to be prepared for them; you ask ChatGPT (hi Mr Roy Lee) to
prep up some
questions for you, but it doesn't seem to go into details much. In this article, I want to put together all the
(compiler related)
questions I've been asked so that you can hopefully get a head start in your recruiting.

Company names will be replaced by names of dishes for anonymity reasons, and to also avoid tunnel-visioning. There
won't be any name-dropping. There
also won't be no behavioral questions mentioned.

All the code I have written for the interviews (including pseudocode) is in C++17/20.

The questions compiled here,
as well as my perspective on each interview round, have been written since November 2024.


## Pre-December 2024

During this time starting between Aug 2024 to December 2024, my mind was still dull and unsharpened. Limited interviews
and leetcoding
from the previous year have frozen my leetcode, technical and behavioral interview skills.
I started and had been doing
leetcode on the daily throughout the timeline to get back into the game.

Having bought leetcode premium (for editorial viewing), I also joined the leetcode discord server to help keep me in
check. Back then, I also did
every daily problem on the leetcode website. It's really cute :) You get to have a medal at the end of the month if
you don't miss any day; they also have two rewind tickets for you if you miss a day.
I also focused a lot on easy and medium, and oftentimes I came back to the same problems multiple times to imprint
the problems in my brain.


![medals](/blogs/compiler_questions_where_to_find_them/medals.jpg)

By the time the pre-December period ended, I
would have done around 350
leetcode
problems.

Beginning of August 2024, I hadn't yet taken any advanced compiler course, nor had I been focused on my own toy
compiler project. The GSoc project for gccrs had just started to wrap up; with now only two compiler projects, I was
still struggling to frame my
résumé in
the best light for
potential compiler employers.

I could feel a hint of despair and helplessness in my heart myself whenever I click "send"
on an application.

### Pad Kee Mao

One of my first interviews for the recruiting season.
5 rounds of technical interviews. The company really loves leetcode-typed questions.

#### Round 1
Question is [Leetcode 1462 - Course Schedule IV](https://leetcode.com/problems/course-schedule-iv/description/)

I read the problem statement and coded up the solution, step by step explaining it to them.

There were some bugs in my code.
But I debugged it and fixed it right away.
After the code passed the test case, the interviewer asked how I can speed it up.
I answered by using cache on the edges of the graph.
The interviewer then explained that caching was good but hinted that caching on the nodes of the graph was more
efficient.
I agreed with them and provided pseudocode for the implementation.

Shortly after this, we ended the interview.
#### Round 2
Question is [Leetcode 39 - Combination Sum](https://leetcode.com/problems/combination-sum/description/)

I spent around 10–15 minutes to walk over an example, asked the interviewer about the constraints as well as coding up
the implementation.

There were 2–3 followup questions:

- What is the time and space complexity of this? (Hint: constant time for an upper limit on the input size, but please
explain
this in
detail)
- How do we make sure we don't waste time computing the combination sums that doesn't have an answer? (Hint: think
about the comparison between the sum of all elements and the target being asked)
- Given a big list of elements to sum up, and a large number n, and around 1000–2000 machines, at a high level, how
would you parallelize this? (Hint: think about when you first split up the big problem into smaller subproblems, how
that exposes the independence between them.)

#### Round 3

The interviewer started with non-leetcode questions, then they transitioned into leetcode questions.

- (Why is)/(Give a reason why) hardware important for faster inference of machine learning models? (Hint: think
about information/memory traversing time in the hardware, how custom hardware can make this better, don't be afraid
to ask ChatGPT for some help, I did it after the interview ended, you might as well do it before the interview hahaha)
- [Leetcode 198 - House Robber](https://leetcode.com/problems/house-robber/description/)
- [Leetcode 2016 - Maximum difference between increasing elements](https://leetcode.com/problems/maximum-difference-between-increasing-elements/description/)

Follow-ups on leetcode questions were still the same: "what's the time and space complexity?"
#### Round 4

Interview provided me with the schematics for the untyped lambda calculus syntax and asked me to code up a
recursive
descent lexer/parser combination for
it . I was
kind of taken off guard
by the question a bit. But I had been hand-writing recursive descent parser in my compiler project, so I kinda got the
general idea.

I was grateful (?!) that they didn't ask about operator precedence climbing as well as pratt parsing as I didn't get
into them until after December 2024.

In this economy,
it's hard to know what questions will be thrown at you. Please be prepared for operator precedence climbing and
pratt parsing by implementing a simple calculator with +, -, *, /, (, ) yourself.

It's better to be defeated but not rejected in your
own IDE than to be defeated as well as rejected in an interviewer's CoderPad.

## Post-December 2024

The post-December era seemed like Luffy's post-timeskip in One Piece.
I am much more confident in my interviewing skills now.

My résumé's also been much more refined with my graduate class
project.

Interviewing with a lot of stray companies has made me more indifferent, more efficient and better at
the recruiting process. Ghosting or generic rejections don't bother me as much. Rejections just mean there are better
candidates than me; they are a much better fit than me, and that I need to strive to better myself more.

I learned that in a competitive market, it is important to market oneself to the employers. Thus, I polished my
website and published a lot of blogs, and posted them on LinkedIn, X, bluesky for visibility, meanwhile
advertising
in each blog article that I am actively looking for a full time compiler job. An employee from a company
has reached out, as well as recruiters from top companies to offer referral or advancement to bypass OA and straight to
the interviewing stage. More often than the other way around, I reached out to employees myself, and had secured a
few referrals for myself.

It is important to keep on improving and advocating for yourself, especially in an over-saturated market, whether it is
through
your projects, leetcode,
resume or
general marketing and networking. I can't stress that fact enough; please never forget that.

By the time I wrapped up my recruitment process, my leetcode count has hit 500+, compared to the pre-December period
of ~350 leetcodes.

### Macaroni and Cheese
3 rounds of technical leetcode interviews. I'm beginning to be convinced that companies really like leetcode questions,
even in
compilers.
#### Round 1
A leetcode-styled question on a string-stack-parsing problem.

Given a string of "add(mul(5,2), 3)", produce the final numeric answer. (Hint: if you're a compiler person, on a
high level,
think
about this in terms of phases, from the perspective of lexing tokens first, and then transition into parsing)

The interviewer then asked me to provide the complexity of the problem.
End of round, they asked "which area interests you the most in cs," of course the answer is "compilers" hahahaha.
They also asked "outside of your technical areas, what do you enjoy doing." I said "reading up on social issues and
technical writings."

#### Round 2

Another leetcode-styled question, this one is named "Bit-flip."

Given a monochrome bitmap represented as a flat array of bytes, with one bit per pixel, flip it horizontally in-place.
The follow-up question was "if you have a lot of requests, what kind of optimization/parallelization can you perform"

The problem was 3-fold. It tested if the interviewee could map indices from 2D array to 1D array. It then tested if
interviewee was comfortable with bit manipulation. Finally, it tested the interviewee's ability to parallelize the
problem.
#### Round 3

This time it's another modified version of an official problem that I know of:
[Leetcode 63 - Unique Paths II](https://leetcode.com/problems/unique-paths-ii/description/)

I didn't have much passing impression with this round, just the fact that we bonded over our usage of vim/nvim in
our daily work life :)

### Sinigang ng hipon

Interviewers in this company asked a lot of tricky and hard problems. Some are straight examples of compiler
optimization, some are leetcode hards, some are related to compiler + AI.

Together with `Takoyaki` and `Honey Almond Cream Cheese Bagel`, the three companies asked really hard and creative
questions, all have caught me off-guard in different ways.

#### Round 1

Given a sequence of matrix multiplication (for example, in a convolutional neural network), optimize the order of matrix
multiplication such that we
use
the least
amount of memory other than the pre-existing memory used to store the matrices.

For example;
```
A = ARR(12000x7)
B = ARR(7x3000)
C = ARR(3000x9000)
D = ARR(9000x15000)
E = ARR(15000x2)

Result R = AxBxCxDxE.

Should we do BxC first? or CxD first? How about AxB? Please algorithmically figure this out.
```

This problem ([Matrix Chain Multiplication](https://en.wikipedia.org/wiki/Matrix_chain_multiplication)) can be
solved in $O(2^n)$ time naively or $O(n^3)$ time with dynamic
programming. There are also an $O(n\log n)$ solution and another $O(n)$ approximation solution. I rank it a leetcode
hard. I could only come up with the naive solution.

The interviewer then asked me about the middle end of the compiler:
- "Have you worked on any SSA form in your project or experience?"
- "Explain to me common subexpression elimination"
- "What kind of compiler optimization have you dealt with?"

#### Round 2
Another leetcode hard, this time it is [Leetcode 127 - Word ladder](https://leetcode.com/problems/word-ladder/description/)

I have done the problem 2 or 3 times over, and was able to answer this.

With my high level answer (and code) containing an `std::unordered_map{:cpp}` of `std::string{:cpp}` to set of
`std::string{:cpp}` as pseudo-edge between a pseudo word and the original words as follows,
the interviewer then asked me if there were any way to optimize the space usage:
```cpp
std::unordered_map<std::string, std::unordered_set<std::string>> dict;

for (auto &word : wordList) {
    for (int i = 0; i < word.size(); i++) {
        auto transformed_word = word.substr(0, i) + "*" + word.substr(i+1);
        dict[transformed_word].insert(word);
    }
}
...
```

I then told them we can turn the `std::unordered_map{:cpp}` into a [trie](https://en.wikipedia.org/wiki/Trie), and
that we can map a `transformed_word` to
an `std::unordered_set{:cpp}` of a pair of `std::string_view{:cpp}` instead of constructing a full string everytime to
optimize on space.

In this round as well as round 1, in retrospect, I don't think I could come up with the (efficient) solution
without seeing them previously. It is sadly the current state of affairs in an employers' market.

The interviewer also asked me stuff about C++, a few examples are: "what's a smart pointer?", "when you first
construct a unique ptr, it assumes the ownership of object, yet you can still assign the construction of that unique
ptr to a variable, why is that?" (Hint: std::move and rvalue), "How do shared ptrs work?"
#### Round 3

The interviewer started off with "how would you lower a convolution down to some specific architecture or to a lower
form of IR?" (Hint: I actually have no hint. I don't know how to answer this question...)

Interviewer also asked about my projects with GPU and AI. I didn't have much experience in the areas and thus could
not answer either question. I was still trying to improve in the area and was feeling pretty defeated. The interview
ended shortly after.

### Honey Almond Cream Cheese Bagel

#### Round 1
The pre-screen round (round 1) started off with
[Leetcode 509 - Fibonacci](https://leetcode.com/problems/fibonacci-number/description/)

Interviewer asked me to implement the naive, recursive approach. Then moved on to ask me how I would test them and
asked me
to come up with different ways to test this. They also asked me to make sure the test wasn't just reusing the linear
pattern: testing $f(1)$, then $f(2)$, then $f(3)$ as the implementer could easily exploit the linear nature.

I said let's break the fibonacci instance recursively into its sum.
like $f(3) = f(2) + f(1) = 2(f1) + f(0)$ and test each of them, despite me not knowing how to actually break it up
hahha.

They said this could work. But another (easier) way was to perform randomized testing: pick a number randomly in a
range and
test it.

They then asked for complexity of fibonacci. I said this is $O(2^n)$ from the master theorem, or we can see that each
time,
we
recomputed
the subproblem twice, leading to $O(2^n)$.

They asked me for my choice of types as input and output to the function. What would happen user put in negative number?
I proposed `uint64_t{:cpp}` in C++ and then they asked me "why not just use `unsigned{:cpp}`." I said that different
platforms
might
have different meaning for `unsigned{:cpp}`, that "I felt really weird about using `unsigned{:cpp}`, and that "users
might have chosen to use our
fibonacci library over our competitor partly due
to the
reliability of our implementation. If they can't count on the fact that different platforms with the same library
will provide the same result, I think that speaks to us and our software engineering practices."

They then asked me to do the iterative implementation.
I admittedly used a different naming convention for my variables,
and I think that must have made the interviewer think I was struggling. They directed me to have two variables, now
named
`current` and `prev`.
During this time, I really felt I've nailed it down, so I took initiative, asked the interviewer to trust me and let me code the implementation.

Things slowly got more complicated. They then asked for the iterative version's run time and memory complexity. I was
also asked to test the iterative
version as well,
so I then
had to
refactor the
original
test to accept a callable instead (with `std::function{:cpp}`). I embarrassingly needed the interviewer to remind me
how to
embed a function signature to a function parameter, as I didn't remember the old school way with function pointers in
C++.

Interviewers then finally asked me, "is there any other way to speed this up?" I thought they meant complexity-wise, so I
answer "yes, with matrix multiplication this goes to $O(log(n))$." They indicated they were more looking for this
behavior
"User calls $f(1)$ then calls $f(10)$ then $f(20)$. How to speed up?"

I then proposed that we used C++'s `std::map<uint64_t, uint64_t>` to handle this: binary search to the smaller and
nearest cached
instance
to the current input and start the computation from there.

At this point, the interviewer
indicated
that they wanted a language-agnostic name for the data structure, to which I refined on and answered "binary search
tree."

The interviewer seemed satisfied, and we ended this round of interview. I went over the time limit by a few minutes.

This round, as well as the next two rounds, are all highly interactive and back and forth.

#### Round 2

This round tested my knowledge in the middle-end and back-end phase.

Interviewer gave me a piece of code that involves a for-loop, together with array accesses in said for-loop.

```kotlin
fun IDespiseLeetcodeHards(arr: List<Int>, info: List<Int>) {
    for (i in 0 until arr.size) {
        println("Element at index $i is ${arr[i]} with info ${info[arr[i]]}")
    }
}
```

They told me that "this is a safe language, so array accesses, when lowered into assembly, will need to have a
branch that jumps to a section of code that handles error."

After the information, they asked me to "please lower this into assembly, you can ignore $\phi$ nodes but keep in
mind about the SSA value. When lowering, remember that you will need to create a branch and a jump section for the
array bound access."

They also specified that the language also has overflowing checking on its integers, and that "show that via
some compiler optimization, the compiler can guarantee that the overflowing check on `i=i+1` in the IR never happens,
thus
speeding up the program considerably"

After all this, depending on my jump assembly section ordering, they asked me to explain why different placements of
the jump assembly section might affect the execution speed of my executable in my CPU (hint: this depends on the branch
predictor,
cache
size of the
CPU as well as pipelining?!).
#### Round 3

This round was all about the front end as well as the general type-checking.

The interviewer asked me about the different phases of the compiler and how it works (front-end, middle-end, back-end).
They also wanted to know which phase I am the most comfortable with. I told them front-end and middle-end, but I was
willing to dabble in anything.

The interviewer then asked me about my toy compiler project, and what I plan to do next with it. I told them, "I
probably
would want to implement a type checker in the compiler." They then iterated on this, saying "ok, how would you assign
types in
your language initially." After a little bit of thinking, I told them "after the parsing and AST construction
stage, I
would assign types, for example, a `NumberExpr` would probably get a `f64_t` type."

We moved on to talk about if-else type checking. They wanted me to provide pseudocode (in a CoderPad) that type
checks an
If-else expression. I had to quickly make up a struct-like version of the If-Else expr, gave them the high level
overview (of what a laywoman thinks) on what it means that an if-else expression is checked successfully.

They then followed up with "given two types A and B, how would you find out the supertype of those two types. After
this, they followed up with "now that you have the way to find out the
supertype of 2 types, with this in mind, how would you go on to check the supertype of k types?" (Hint: Draw out a
diagram as a tree representing all the types in your language, with the supertype of all types at the root of the tree.)

We then ended the interview.
#### Introspection

This company featured the most interactive and problem-solving aspect in the whole line up, exceeding just a bit
behind Takoyaki. A lot of the questions being asked in this company's interviews really made me think hard about my
answers. The amount of ingenuity and
teamwork the team had displayed to me during my interview made me stand in awe. They really took me back in my
earlier days, when I was a kid being surrounded by Fermilab's brilliant engineers.

I deeply regretted not working more on my toy compiler. If I had implemented a simple bidirectional type
checker for my compiler, the if-else expr type checking question would have been easier—I could have been more
methodical in my answers.
If I had enrolled in
one of
our school's upper divisions in software-hardware architecture instead of randomized algorithms, the question on
lowering assembly would have been easier.  Despite this, I'm still grateful for all the questions the company have
asked, despite their difficulties; they could have easily asked something like "How would you design the type system for
your language's function?"

It was also during this time period that I realized not every answer needed to be perfect. Oftentimes, as long as I
managed to spell out the keywords that the interviewers were looking for, or as long as I was progressing towards the
goal, interviewers were willing to guide me to get to the question's answer myself.

The interview process with the company had ignited my drive to work harder to better myself.  The recruiter
thankfully gave me very helpful feedback: "you have some of the
skills we're looking for, but it's not there yet." I was grateful for the recruiter's transparency. Needless to say,
what
followed next was a rejection.

### Takoyaki

The Takoyaki company process was completely different from the rest of the line-up. If Honey Almond Cream Cheese
Bagel wanted to gauge my skills through providing actual pseudocode for simulated problems, then Takoyaki opted for
repeatedly hard-hitting questions in different areas in random orders that were tailored specifically to my résumé.

#### Round 1 & 2

The company seemed really
interested in
trying to know me
as a person,
through my résumé as well as my thoughts on certain topics.
As a result, they asked me a ton of questions about my resume, about my experience in GSoc gccrs, about
MLIR, about the difference between GCC Tree IR versus llvm-ir; let's just say that if
a project has the word
"compiler" or "programming languages,", they were gonna ask, in detail, each word and each line that I wrote in the
résumé. It really felt like they were looking for a true independent thinker who's also a problem solver in their own
ways. Despite this, not a single leetcode questions or programming questions were asked in both rounds.

They also asked me that in one of my compiler projects, did it have error reporting? I reluctantly said no, and that's
why I
incorporate that feature and wrote about it in this [article](what_after_kalei_location_debug).

There are also non-resume questions:
- "What's the most important thing in software engineering, according to you" - I told the interviewer that
it's "building tools."
- "On a high level, how would you debug a JIT compiler" - Hahah this is a hard question. I talked about how
difficult it is to
debug a JIT compiler instead.
- "On a high level, how would you debug/detect a memory bug" — Static analyzer, sanitizers, gdb, and lldb.
- "How useful do you think AI is in your day-to-day workflow" - It's not good enough, but it's helpful for searching
for documentation.
- "What, to your knowledge, might be a difference in a compiler's AST and HIR?" (Hint: syntax desugaring, custom SSA
IR form, sometimes it also happens that your compiler typechecking and such only exists in the HIR level (this is
true in gccrs) so even though there might be no difference in a compiler AST and HIR, there is a difference in the
visitor pattern in a compiler's AST and HIR stage)
- "Described how you would debug an issue that popped up on your most recent commit" - Domain specific knowledge and
git bisect. I also told them I like to pose hypothesis and test them out to guide me to the underlying issue.
- "What do you like to do outside coding, in a business setting? There may be other roles you can take on" -
Same as the `Sinigang ng hipon` interviewer in round 1, my answer is technical writing.
- "What OS would you like to use for compiler dev?" — I answered them: "I have a Macbook right now, but it's a pain to
set up LLVM on macOS, I'd like to switch to Ubuntu, it's just a popular linux distribution."
- "What's your favorite programming language?" — I actually don't know if I have a favorite language :) Rust is
probably one of
them. C++ scores pretty high on the nostalgic feel as well. It's hard.
- "How does linear register allocation work?" - No hint for this question.
### Phở

I have a disclaimer to make. Phở is actually not a single company. But it's actually an amalgamation of different
companies' questions that were asked. I want to add all the relevant questions that I was asked, not a
single question wasted.
Hence, the name.

#### Questions

- "What do you like about programming languages and compilers?"
- "It is possible to perform dataflow analysis on non-SSA values, even so, we keep on insisting on transforming
our IR to SSA-IR form. What's going on here?"
- "Tell us about all the compiler optimization you can think of"
- [Leetcode 38 - Count and say](https://leetcode.com/problems/count-and-say/description/)
- "What's your experience with CMake?"
- "Which version of C++ are you using daily?"
- "What's your experience with AI models and Python?"
- "What's your experience with quantum computing?"
- "Explain to me what's the visitor pattern?"
- "Explain to me what's the concept of the mixins pattern?"
- "You'll notice that when you make a class in C++, you cannot make the class's templated method virtual as well.
Why is
that?" (Hint: something about vtables, hmmm)
- [Leetcode 90 - Subsets II](https://leetcode.com/problems/subsets-ii/description/)
- "We highly value inclusivity together with diversity here at the company. Can you tell us your experience
(professional or not) that speaks to this aspect? It doesn't need to be a 1-to-1 match."
- "What do you feel about free software?"
- "We care deeply about giving back and contributing to open source software, have you had any experience in this facet?"
- "As the job application (that you have read and applied) for the compiler team is about the development of our
language SkibidiToiletRizz, can you tell us (even if you haven't coded in it) what you like about the language? What
about it that you don't like?" (Hint: make sure that you actually search up the language beforehand, don't be like me)
- "Given the following piece of code, tell me what's the run time complexity of the executable after possible
compiler optimizations":
```cpp
int FreeMeFromLeetcodeHards(const std::vector<int> &v) {
    int sum = 0;

    for (int i = 0; i < v.size(); i++) sum += v[i];

    return 42;
}
```

- "If, in testing, my algorithm implementation from a paper runs twice as slow when my input size $n_2=200$ is twice
bigger
than my initial input size of
$n_1=100$, does
that mean my implementation is linear in its complexity? Give your reasoning or counter examples on why it is or is
not. If it is not linear in its complexity, what would you do to confirm/reject this hypothesis?" (Hint: something
to do with plotting and coefficients and hidden constants)
- "Now if you're still struggling with the previous question, let me ask you this, what if in testing another
algorithm's implementation, my run time is now $4=2^2$ times as slow when my input size is $n_2=1000$, doubled
compared to when my
input size was
$n_1=500$, does it mean that my implementation is $O(n^2)$?"

# Epilogue

The recruiting process has been one of the most stressful times in my life. Countless times I've felt my heart
pounding, my arms and knees get a little weak from thinking about all these processes.

Despite this, I've also been grateful for the situation that I'm in. With the current competitive and dire market,
a lot of people who are significantly smarter and harder working than me who are not able to find a job in this
economy, just because they're international.
My heart goes out for those people.

Here are some pictures documenting my emotions throughout the process. Thank you for reading.

![eecs1](/blogs/compiler_questions_where_to_find_them/eecs1.jpg)
![eecs2](/blogs/compiler_questions_where_to_find_them/eecs2.jpg)
![eecs3](/blogs/compiler_questions_where_to_find_them/eecs3.jpg)

![aut1](/blogs/compiler_questions_where_to_find_them/aut1.jpg)

![interview](/blogs/compiler_questions_where_to_find_them/interview.jpg)
![interview2](/blogs/compiler_questions_where_to_find_them/interview_2.jpg)

![gibberish](/blogs/compiler_questions_where_to_find_them/gibberish.jpg)

![b1](/blogs/compiler_questions_where_to_find_them/b1.jpg)
![b2](/blogs/compiler_questions_where_to_find_them/b2.jpg)
![b3](/blogs/compiler_questions_where_to_find_them/b3.jpg)
