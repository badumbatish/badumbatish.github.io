---
title: 'Compiler (related) questions and where to find them'
date: 2025-4-17
recap: "Jasmine helps new grads in compiler by sharing interview questions through her new grad recruiting journey"
---

# Prologue

Hi everyone, how's everyone doing? It's been a while since I've written another blog. I'm doing good :) This May
2025,
I'm graduating and happy to announce that I'm starting my employment at Igalia this June hacking on compilers :)

Igalia is a
"worker-owned, employee-run cooperative model consultancy focused on open source software" and I'm so happy I am
accepted and offered to work here. I'll be working remotely from home, hacking on compilers :) Besides the
diversity and the worker cooperative model, family and work-life
balance also play a huge role in my life, hence my pick for Igalia.

During my compiler-focused recruiting time, in interviews, I got asked a lot of compiler-related questions and I felt
really
under-prepared for them. I of course have some experience in compilers, but there wasn't a database like leetcode
that you
can turn to to practice and hone your compiler skills. I want to write this article to talk about compiler (related)
questions
asked in interviews,
to share with everyone who's
looking for a junior job; maybe it can help you with your compiler recruiting.

I want to also extend my acknowledgement to everyone who believed in me and supported me throughout.

- My family: you already know what it is haha
- Emi & Noah: for being there for me and helping me with offer decisions :)
- Lizzie: your mom hhahahah
- Tim: For your help in the Igalia process.
- Ish: for your "youll b fine" and "itll b fine" affirmations :)
- Quân: for Yosemite and for everything since 2023.
- Carol: For your acceptance and support to me during Fermilab's CCI and SULI program. You helped shape my early-early-early career.
- Eduardo: For befriending me and for shuriken-analyzer :)
- Antonio: For referring me to mmm and nnn :)
- Arthur: for your support during GSoc and GT.
- Josh: For referring me to different companies, helping me with offer negotiation and going on walks with me :)
- Nicole, Roger and everyone for your patience.
- Brian and James: For our little biweekly meet up since 2023 :)
- Max & Audrey: for your CS265 class and for SIGPLAN-M :)
- Jasmangle: for chatting with me through the hiring cycles and helping me with my leetcode.
- Ahmad: for chatting and being dumb with me through the latter half of the recruitment cycle.
- Barbara: for practicing Leetcode with me (fall 2024).
- Sriram: For your reference.
- Iman: For referring me to xxx and yyy :) I'll always be grateful to you.

As is tradition :) I also want to recommend two songs for this article. One is
[Ashes to Amber by Iris](https://youtu.be/UfvULU7lx4w?si=NMlUofaIGxrRST8N) and the other
one is [Strawberry Sunscreen by Lostboycrow](https://youtu.be/eUCHyIfgnag?si=_WTWbSJzplEHmEWY).

Both give my heart this feeling that summer is coming through soon; that the heat of youth will strive again and
that I'll be on the beach again :) I guess now you know which season is my favorite :)
# Introduction

> It's often discouraging as a new grad to feel like no matter how much effort you put in, it's never quite enough.

In
this currently dire and over-competitive economy, once you
apply for a role,
it's
hard to compete and get past the OA stage; once you get past the OA stage, it's
hard to compete and get
past the resume
screen
stage; once you get
past the resume screen stage, it's hard to compete and get past the interview stage.

Companies are asking (compiler) questions that are often not
addressed in your average compiler class, and it's hard to be prepared for them; you ask ChatGPT to prep up some
questions for you, but it doesn't seem to go into details much. In this article, I want to put together all the
(compiler related)
questions I've been asked so that you can hopefully get a head start in your recruiting.

Company names will be replaced by names of dishes for anonymity reasons, and to also avoid tunnel-visioning. There
won't be any name-dropping. There
also won't be no behavioral questions mentioned.

All the code I have written for the interviews (including pseudocode) is in C++17/20.

The questions compiled here,
as well as my perspective on each interview round, have been written since November 2024.
I hope
everyone enjoys :)

## Pre-December 2024

During this time starting between Aug 2024 to December 2024, my mind was still dull in the game. Limited interviews
and leetcoding
from the previous year have frozen my leetcode and behavioral interview skills.
I started and had been doing
leetcode on the daily throughout the timeline to get back into the game.

Having bought leetcode premium (for editorial viewing), I also joined the leetcode discord server to help keep me in
check. Back then, I also did
every daily problem on the leetcode website. It's really cute :) You get to have a medal at the end of the month if
you don't miss any day; they also have two rewind tickets for you if you miss a day.
I also focused a lot on easy and medium, and oftentimes I came back to the same problems multiple times to imprint
the problems in my brain.


![medals](/blogs/compiler_questions_where_to_find_them/medals.jpg)

By the time the pre-December period ends, I
would have done around 350
leetcode
problems.

Beginning of August 2024, I hadn't yet taken any advanced compiler course, nor had I been focused on my own toy
compiler project. The GSoc project for gccrs had just started to wrap up; with now only two compiler projects, I was
still trying to frame my
résumé in
the best light for
potential compiler employers.

I could feel a hint of despair and hopelessness in my heart myself when I click "send"
on an application.

### Pad Kee Mao

One of my first interviews for the recruiting seasons.
5 rounds of technical interviews. The company really loves leetcode-typed questions.

#### Round 1
Question is [Leetcode 1462 - Course Schedule IV](https://leetcode.com/problems/course-schedule-iv/description/)

I read the problem statement and coded up the solution, step by step explaining it to them.

There were some bugs in my code.
But I debugged it and fixed it right away.
After the code passed the test case, the interviewer asked how I can speed it up.
I answered by using cache on the edges of the graph.
The interviewer then explained that caching was good but hinted that caching on the nodes of the graph was more
efficient.
I agreed with them and provided pseudocode for the implementation.

Shortly after this, we ended the interview.
#### Round 2
Question is [Leetcode 39 - Combination Sum](https://leetcode.com/problems/combination-sum/description/)

I spent around 10–15 minutes to walk over an example, asked the interviewer about the constraints as well as coding up
the implementation.

There were 2–3 followup questions:

- What is the time complexity of this? (Hint: constant time for an upper limit on the input size, but please explain
this in
detail)
- How do we make sure we don't waste time computing the combination sums that doesn't have an answer? (Hint: think
about the comparison between the sum of all elements and the target being asked)
- Given a big list of elements to sum up, and a large number n, and around 1000–2000 machines, at a high level, how
would you parallelize this? (Hint: think about when you first split up the big problem into smaller subproblems, how
that exposes the independence between them.)

#### Round 3

The interviewer started with non-leetcode questions, then they transitioned into leetcode questions.

- (Why is)/(Give a reason why) hardware important for faster inference of machine learning models? (Hint: think
about information/memory traversing time in the hardware, how custom hardware can make this better)
- [Leetcode 198 - House Robber](https://leetcode.com/problems/house-robber/description/)
- [Leetcode 2016 - Maximum difference between increasing elements](https://leetcode.com/problems/maximum-difference-between-increasing-elements/description/)

Follow up on leetcode questions are still the same: "what's the time complexity?"
#### Round 4

Interview asked me to code up a recursive descent lexer/parser combination for the simply untyped lambda calculus. I was
kind of taken off guard
by the question a bit. But I had been hand-writing recursive descent parser in my compiler project, so I kinda got the
general idea.

I was grateful (?!) that they didn't ask about operator precedence climbing as well as pratt parsing as I didn't get
into them until after December 2024.

In this economy,
it's hard to know what questions will be thrown at you. Please be prepared for operator precedence climbing and
pratt parsing by implementing a simple calculator with +, -, *, /, (, ) yourself.

It's better to feel defeated but not getting rejected in your
own IDE than to feel defeated as well as being rejected in an interviewer's CoderPad.

## Post-December 2024

The post-December era seemed like Luffy's post-timeskip in One Piece.
I am much more confident in my interviewing skills now.

My résumé's also been much more refined with my graduate class
project.

Interviewing with a lot of stray companies has made me more indifferent, more efficient and better at
the recruiting process. Ghosting or generic rejections don't bother me as much. Rejections just mean there are better
candidates than me; they are a much better fit than me, and that I need to strive to better myself more.

I learned that in a competitive market, it is important to market oneself to the employers. Thus, I polished my
website and published a lot of blogs, and posted them on LinkedIn, X, bluesky for visibility, meanwhile
advertising
in each blog article that I am actively looking for a full time compiler job. An employee from a company
has reached out, as well as recruiters from top companies to offer referral or advancement to bypass OA and straight to
the interviewing stage. More often than the other way around, I reached out to employees myself, and had secured a
few referrals for myself.

It is important to keep on improving and advocating for yourself, especially in an over-saturated market, whether it is
through
your projects, leetcode,
resume or
general marketing and networking. I can't stress that fact enough; please never forget that.

By the time I wrapped up my recruitment process, my leetcode count has hit 500+, compared to the pre-December period
of ~350 leetcodes.

### Macaroni and Cheese
3 rounds of technical leetcode interviews. I'm beginning to be convinced that companies really like leetcode questions,
even in
compilers.
#### Round 1
A leetcode-styled question on a string-stack-parsing problem.

Given a string of "add(mul(5,2), 3)", produce the final numeric answer. (Hint: if you're a compiler person, on a
high level,
think
about this in terms of phases, from the perspective of lexing tokens first, and then transition into parsing)

The interviewer then asked me to provide the complexity of the problem.
End of round, they asked "which area interests you the most in cs," of course the answer is "compilers" hahahaha.
They also ask "outside of your technical areas, what do you enjoy doing." I said "reading up on social issues and
technical writings."

#### Round 2

Another leetcode-styled question, this one is named "Bit-flip."

Given a monochrome bitmap represented as a flat array of bytes, with one bit per pixel, flip it horizontally in-place.
The follow-up question is "if you have a lot of requests, what kind of optimization/parallelization can you perform"

The problem was 3-fold. It tested if the interviewee could map indices from 2D array to 1D array. It then tested if
interviewee was comfortable with bit manipulation. Finally, it tested the interviewee's ability to parallelize the
problem.
#### Round 3

This time it's another modified version of an official problem that I know of:
[Leetcode 63 - Unique Paths II](https://leetcode.com/problems/unique-paths-ii/description/)

I didn't have much passing impression with this round.

### Sinigang ng hipon

Interviewers in this company asked a lot of tricky and hard problems. Some are straight examples of compiler
optimization, some are leetcode hards, some are related to compiler + AI.

Together with `Takoyaki` and `Honey Almond Cream Cheese Bagel`, the three companies asked really hard and creative
questions, all have caught me off-guard in different ways.

#### Round 1

Given a sequence of matrix multiplication (for example, in a convolutional neural network), optimize the order of matrix
multiplication such that we
use
the least
amount of memory other than the pre-existing memory used to store the matrices.

For example;
```
A = ARR(12000x7)
B = ARR(7x3000)
C = ARR(3000x9000)
D = ARR(9000x15000)
E = ARR(15000x2)

Result R = A@B@C@D@E.

Should we do B@C first? or C@D first? How about A@B? Please algorithmically figure this out.
```

This problem ([Matrix Chain Multiplication](https://en.wikipedia.org/wiki/Matrix_chain_multiplication)) can be
solved in $O(2^n)$ time naively or $O(n^3)$ time with dynamic
programming. I rank it a leetcode
hard. I could only come up with the naive solution. The interviewer seemed satisfied with the answer, however.

The interviewer then asked me about the middle end of the compiler:
- "Have you worked on any SSA form in your project or experience?"
- "Explain to me common subexpression elimination"
- "What kind of compiler optimization have you dealt with?"

#### Round 2
Another leetcode hard, this time it is [Leetcode 127 - Word ladder](https://leetcode.com/problems/word-ladder/description/)

I have done the problem 2 or 3 times over, and was able to answer this.

In this round as well as round 1, in retrospect, I don't think I could come up with the (efficient) solution
without seeing them previously. It is sadly the current state of affairs in an employers' market.

The interviewer also asked me stuff about C++, a few examples are: "what's a smart pointer?", "when you first
construct a unique ptr, it assumes the ownership of object, yet you can still assign the construction of that unique
ptr to a variable, why is that?"
#### Round 3

Interviewer asked "how would you lower a convolution down to some specific architecture, or to a lower form of IR?"

Interviewer also asked about my projects with GPU and AI. I didn't have much experience in the areas and thus could
not answer either problem. I'm still trying to improve in the area after feeling pretty defeated. The interview
ended shortly after.

### Honey Almond Cream Cheese Bagel

#### Round 1
The pre-screen round (round 1) starts with [Leetcode 509 - Fibonacci](https://leetcode.com/problems/fibonacci-number/description/)

Interviewer asked me to implement the naive, recursive approach. Then moved on to ask me how I would test them and
asked me
to come up with different ways to test this. They also asked me how to make sure the test isn't just reusing the linear
pattern: testing f(1), then f(2), then f(3) as the implementer can easily exploit the linear nature.

I said let's break the fibonacci instance recursively into its sum.
like $f(3) = f(2) + f(1) = 2(f1) + f(0)$ and test each of them.

They said this would work. But another way was to perform randomized testing: pick a number randomly in a range and
test it.

They then asked for complexity of fibonacci. I said this is $O(2^n)$ from the master theorem, or we can see that each
time,
we
recomputed
the subproblem twice, leading to $O(2^n)$.

They asked me for my choice of types as input and output to the function. What would happen user put in negative number?
I proposed `uin64_t{:cpp}` in C++ and then they asked me "why not just use unsigned." I said that different platforms
might
have different meaning for `unsigned{:cpp}`, and that "users use our fibonacci library over our competitor partly due
to the
reliability of our implementation. If they can't count on the fact that different platforms with the same library
will provide the same result, I think that speaks to us and our software engineering practices."

He then asked me to do the iterative implementation.
I admittedly used a different naming convention for my variables,
and I think that must have made the interviewer think I was struggling. They directed me to have two variables, now
named
`current` and `prev`.
During this time, I really felt I've nailed it down, so I took initiative, asked the interviewer to trust me and let me code the implementation.

Things slowly got more complicated. I was asked to test the iterative version as well, so I then have to refactor the
original
test to accept a callable instead (with std::function). I embarrassingly needed interviewer to remind me how to
embed a function signature to a function parameter, as I didn't remember the old school way with function pointers in
C++.

Interviewers then finally asked me, "is there any other way to speed this up?" I thought they meant complexity-wise, so I
answer "yes, with matrix multiplication this goes to $O(log(n))$." They indicated they were more looking for this
behavior
"User calls f(1) then calls f(10) then f(20). How to speed up?"

I then proposed that we used C++'s `std::map<uint64_t, uint64_t>` to handle this: binary search to the smaller and
nearest cached
instance
to the current input and start the computation from there.

At this point, the interviewer
indicated
that they wanted a language-agnostic name for the data structure, to which I refined on and answered "binary search
tree."

The interviewer seemed satisfied, and we ended this round of interview. I went over the time limit by a few minutes.

#### Round 2

Interviewer gave me a piece of code that involves a for-loop, together with array accesses in said for-loop.

```kotlin
fun printArrayElements(arr: List<Int>, info: List<Int>) {
    for (i in 0 until arr.size) {
        println("Element at index $i is ${arr[i]} with info ${info[arr[i]]}")
    }
}
```

They told me that "this is a safe language, so array accesses, when lowered into assembly, will need to have a
branch that jumps to a section of code that handles error."

After the information, they asked me to "please lower this into assembly, you can ignore $\phi$ nodes but keep in
mind about the SSA value. When lowering, remember that you will need to create a branch and a jump section for the
array bound access."

They also specified that the language also has overflowing checking on its integers, and that "show that via
some compiler optimization, the compiler can guarantee that the overflowing check on `i=i+1` in the IR never happens,
thus
speeding up the program considerably"

After all this, depending on my jump assembly section ordering, they asked me to explain why different placements of
the jump assembly section might affect the execution speed of my executable in my CPU (hint: this depends on the branch
predictor,
cache
size of the
CPU as well as pipelining?!).
#### Round 3

This round is all about the front end as well as the general type-checking.

The interviewer asked me about the different phases of the compiler and how it works (front-end, middle-end, back-end).
They also want to know which phase I am the most comfortable with. I told them front-end and middle-end, but I am
willing to dabble in anything.

The interviewer then asked me about my toy compiler project, and what I plan to do next with it. I told them, "I
probably
would want to implement a type checker in the compiler." They then iterated on this, saying "ok, how would you assign
types in
your language initially." After a little bit of thinking, I told them "after the parsing and AST construction
stage, I
would assign types, for example, a `NumberExpr` would probably get a `f64_t` type."

We moved on to talk about if-else type checking. They wanted me to provide actual pseudocode that type checks an
If-else expression. I had to quickly make up a struct-like version of the If-Else expr, gave them the high level
overview (of what a laywoman thinks) on what it means that an if-else expression is checked successfully.

They then followed up with how I would figure out that given two types A and B, find the type that is the
supertype of those two types. After this, they followed up with "now that you have the way to find out the
supertype of 2 types, with this in mind, how would you go on to check the supertype of k types?"

We then ended the interview.
#### Introspection

This company featured the most interactive and problem-solving aspect in the whole line up, exceeding just a bit
behind Takoyaki. A lot of the questions being asked in this company's interviews really made me think hard about my
answers. The amount of ingenuity and
teamwork the team had displayed to me during my interview made me stand in awe. They really took me back in my
earlier days, when I was a kid being surrounded by Fermilab's brilliant engineers.

I deeply regretted not working more on my toy compiler. If I had implemented a simple bidirectional type
checker for my compiler, the if-else expr type checking question would have been easier. If I had enrolled in one of
our school's upper divisions in software-hardware architecture instead of randomized algorithms, the question on
lowering assembly would have been easier.

It was also during this time period that I realized not every answer needed to be perfect. Oftentimes, as long as I
managed to spell out the keywords that the interviewers are looking for, or as long as I was progressing towards the
goal, they were willing to guide me to get to the question's answer myself.

The interview process with the company had ignited my drive to work harder to better myself.  The recruiter thankfully gave me very helpful feedback: "you have some of the
skills we're looking for, but it's not there yet." Needless to say, what
followed next was a rejection.
### Takoyaki
The Takoyaki company process is completely different from the rest of the line up. If Honey Almond Cream Cheese
Bagel wanted to gauge my skills through providing actual pseudocode for simulated problems, then Takoyaki opted for
repeatedly hard-hitting questions in different areas in random orders that are tailored specifically to my résumé.
#### Round 1 & 2

The company seemed really
interested in
trying to know me
as a person,
through my résumé as well as my thoughts on certain topics.
As a result, they asked me a ton of questions about my resume, about my experience in GSoc gccrs, about
mlir, about the difference between GCC Tree IR versus llvm-ir; let's just say that if
a project has the word
"compiler" or "programming languages,", they're gonna ask, in detail, each word and each line that I wrote in the
resume. It really felt like they were looking for a true independent thinker who's also a problem solver in their own
ways. Despite this, not a single leetcode questions were asked in both rounds.

They also asked me that in one of my compiler projects, does it have error reporting? I reluctantly said no, and that's
why I
incorporate that feature and wrote about it in this [article](what_after_kalei_location_debug).

There are also non-resume questions:
- "What's the most important thing in software engineering, according to you" - I told the interviewer that
it's "building tools."
- "On a high level, how would you debug a JIT compiler" - Hahah this is a hard question.
- "On a high level, how would you debug/detect a memory bug" - Static analyzer, sanitizers, gdb, and lldb.
- "How useful do you think AI is in your day-to-day workflow" - It's not good enough, but it's helpful for searching
for documentation.
- "What, to your knowledge, might be a difference in a compiler's AST and HIR?" (Hint: syntax desugaring, custom SSA
IR form, sometimes it also happens that your compiler typechecking and such only exists in the HIR level (this is
true in gccrs) so even though there might be no difference in a compiler AST and HIR, there is a difference in the
visitor pattern in a compiler's AST and HIR stage)
- "Described how you would debug an issue that popped up on your most recent commit" - Domain specific knowledge and
git bisect. I also told them I like to pose hypothesis and test them out to guide me to the underlying issue.
- "What do you like to do outside coding, in a business setting? There may be other roles you can take on" -
Same as the `Sinigang ng hipon` interviewer in round 1, my answer is technical writing.
- "What OS would you like to use for compiler dev?" - I answered them "I have a Macbook right now, but it's a pain to
set up LLVM on macOS, I'd like to switch to Ubuntu, it's just a popular linux distribution."
- "What's your favorite programming language?" — I actually don't know if I have a favorite language :) Rust is
probably one of
them. C++ scores pretty high on the nostalgic feel as well. It's hard.
- "How does linear register allocation work?"
- "We highly value inclusivity together with diversity here at the company. Can you tell us what you have done
outside professional experience that speaks to this aspect? It doesn't need to be a 1-to-1 match, some volunteer
experience will suffice."

# Epilogue

The recruiting process has been one of the most stressful times in my life. Countless times I've felt my heart
pounding, my arms and knees get a little weak from thinking about all these processes.

Despite this, I've also been grateful for the situation that I'm in. With the current competitive and dire market,
a lot of people who are significantly smarter than me who are not able to find a job in this economy, just because they're international.
My heart goes out for those people.

I feel that I need to acknowledge my privileges. I want to acknowledge that I've never had to work during the
semesters at Berkeley
and that I've
always had a stable
apartment
under my head, with supporting family and friends to care for me. That the school I go to, UC Berkeley, offers one
of the highest quality of education I can ever dream of. These factors played a huge role in how prepared
I am for these interviews and have afforded me the
opportunities to work on more projects and leetcode more to improve my résumé and problem-solving skills. These are
privileges that I think are
important to acknowledge.

But I also have disadvantages. It's hard for me to focus on a single problem for too long; I lose focus on
non-interesting
stuff. I have problems
with
spelling out numbers. I'm a transgender woman of color, who for every 2-4 months, has to take blood tests
for ~$200. A
child of immigrants from Vietnam, I
have
had to work
graveyard shifts
in UPS trailers, hauling heavy boxes and packages for shipping to support myself and my family
through covid. A
child of
immigrants, I have to wait a year for california resident tuition to kick in before I can attend community college.
A child of immigrants, I have no other way
but to attend community college instead of attending a public university from the get-go, lest I want to pay an
exorbitant
amount of money that I don't have to attend private university.

In acknowledging my privileges and shortcomings, I don't mean to erase or elevate my success. These experiences
may complicate my achievements, but more importantly, they absolutely enlighten new grad readers a vision to paint a
path to success for themselves.
Every journey is messy and unique, entangled with each person's
characteristics and environments. Mine is no exception—yet within its nuances, others may find the courage to forge
their own.

Here are some pictures documenting my emotions throughout the process. Thank you for reading.

![eecs1](/blogs/compiler_questions_where_to_find_them/eecs1.jpg)
![eecs2](/blogs/compiler_questions_where_to_find_them/eecs2.jpg)
![eecs3](/blogs/compiler_questions_where_to_find_them/eecs3.jpg)

![aut1](/blogs/compiler_questions_where_to_find_them/aut1.jpg)
![interview](/blogs/compiler_questions_where_to_find_them/interview.jpg)

![gibberish](/blogs/compiler_questions_where_to_find_them/gibberish.jpg)

![b1](/blogs/compiler_questions_where_to_find_them/b1.jpg)
![b2](/blogs/compiler_questions_where_to_find_them/b2.jpg)
![b3](/blogs/compiler_questions_where_to_find_them/b3.jpg)
